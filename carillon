#!/usr/bin/env python3
import json
import os
import shlex
import signal
import subprocess
import sys

import urwid


class CarillonDisplay:
    def __init__(self):
        self.title = urwid.Edit('Title: ')
        self.composer = urwid.Edit('Composer: ')
        self.live = urwid.CheckBox('Live')

        self.update_button = urwid.Button('Update', self.update)
        self.clear_button = urwid.Button('Clear', self.clear)
        self.buttons = urwid.Columns([(10, self.update_button), urwid.Divider(), (9, self.clear_button)])
        self.feedback = urwid.Text('', align='center')
        self.feedback_timer = -1

        self.pile = urwid.Pile([self.title, self.composer, self.live, urwid.Divider(), self.buttons, urwid.Divider(), self.feedback])

        self.loop = urwid.MainLoop(urwid.Filler(urwid.Padding(self.pile, width=40, align='center')))

        self.last_mtime = 0

        self.running = True
        self.clear()
        self.feedback_timer = 0
        self.refresh()
        self.running = False

    def run(self):
        self.running = True
        self.loop.run()

    def exit(self):
        self.running = False

    def refresh(self, _=None, __=None):
        mtime = os.stat(os.path.dirname(__file__) + '/www/details.json').st_mtime
        if mtime > self.last_mtime:
            self.last_mtime = mtime

            with open(os.path.dirname(__file__) + '/www/details.json', 'r') as file:
                data = json.loads(file.read())
                self.live.state = data['live']
                self.title.edit_text = data['title']
                self.composer.edit_text = data['composer']

        if self.feedback_timer == 0:
            self.feedback.set_text('')

        if self.feedback_timer >= 0:
            self.feedback_timer -= 1

        if not self.running:
            raise urwid.ExitMainLoop()

        self.loop.set_alarm_in(1, self.refresh)

    def update(self, _=None):
        with open(os.path.dirname(__file__) + '/www/details.json', 'w') as file:
            file.write(json.dumps({'live': self.live.state, 'title': self.title.edit_text, 'composer': self.composer.edit_text}))

        self.feedback.set_text('Stream metadata updated!')
        self.feedback_timer = 3

    def clear(self, _=None):
        self.title.set_edit_text('None')
        self.composer.set_edit_text('None')
        self.live.set_state(False)

        self.update(_)


os.chdir(os.path.dirname(__file__))


nginx_cmd = ['/bin/sh', 'conf/nginx.sh']
ffmpeg_cmd = ['/bin/sh', 'conf/ffmpeg.sh']
update_cmd = ['/bin/sh', 'conf/upd.sh']


if __name__ == '__main__':
    try:
        nginx = subprocess.Popen(nginx_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
        ffmpeg = subprocess.Popen(ffmpeg_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
        update = subprocess.Popen(update_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)

        display = CarillonDisplay()

        signal.signal(signal.SIGINT, lambda signum, siginfo: display.exit())
        signal.signal(signal.SIGTERM, lambda signum, siginfo: display.exit())
        signal.signal(signal.SIGCHLD, lambda signum, siginfo: display.exit())

        display.run()
    finally:
        try:
            ret = nginx.poll()
            if ret:
                sys.stderr.write('nginx returned an error ({})\n'.format(ret))
            else:
                nginx.terminate()
                nginx.wait()
        except:
            pass
        try:
            ret = ffmpeg.poll()
            if ret and ret != 255:
                sys.stderr.write('ffmpeg returned an error ({})\n'.format(ret))
            else:
                ffmpeg.terminate()
                ffmpeg.wait()
        except:
            pass
        try:
            ret = update.poll()
            if ret:
                sys.stderr.write('updater returned an error ({})\n'.format(ret))
            else:
                update.terminate()
                update.wait()
        except:
            pass
