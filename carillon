#!/usr/bin/env python3
import configparser
import json
import os
import signal
import subprocess
import sys

import urwid


class CarillonDisplay:
    def __init__(self):
        self.title = urwid.Edit('Title: ')
        self.composer = urwid.Edit('Composer: ')
        self.live = urwid.CheckBox('Live')

        self.update_button = urwid.Button('Update', self.update)
        self.clear_button = urwid.Button('Clear', self.clear)
        self.buttons = urwid.Columns([(10, self.update_button), urwid.Divider(), (9, self.clear_button)])
        self.feedback = urwid.Text('', align='center')
        self.feedback_timer = -1

        self.pile = urwid.Pile([self.title, self.composer, self.live, urwid.Divider(), self.buttons, urwid.Divider(), self.feedback])

        self.loop = urwid.MainLoop(urwid.Filler(urwid.Padding(self.pile, width=40, align='center')))

        self.last_mtime = 0

        self.running = True
        self.clear()
        self.feedback_timer = 0
        self.refresh()
        self.running = False

    def run(self):
        self.running = True
        self.loop.run()

    def exit(self):
        self.running = False

    def refresh(self, _=None, __=None):
        mtime = os.stat('www/stream/metadata.json').st_mtime
        if mtime > self.last_mtime:
            self.last_mtime = mtime

            with open('www/stream/metadata.json', 'r') as file:
                data = json.loads(file.read())
                self.live.state = data['live']
                self.title.edit_text = data['title']
                self.composer.edit_text = data['composer']

        if self.feedback_timer == 0:
            self.feedback.set_text('')

        if self.feedback_timer >= 0:
            self.feedback_timer -= 1

        if not self.running:
            raise urwid.ExitMainLoop()

        self.loop.set_alarm_in(1, self.refresh)

    def update(self, _=None):
        with open('www/stream/metadata.json', 'w') as file:
            file.write(json.dumps({'live': self.live.state, 'title': self.title.edit_text, 'composer': self.composer.edit_text}))

        self.feedback.set_text('Stream metadata updated!')
        self.feedback_timer = 2

    def clear(self, _=None):
        self.title.set_edit_text('None')
        self.composer.set_edit_text('None')
        self.live.set_state(False)

        self.update(_)


os.chdir(os.path.dirname(__file__))


config = configparser.ConfigParser()
config.read('carillon.cfg')


components = {
    'http': {
        'name': 'web server',
        'cmd': [sys.executable, '-m', 'http.server', '-b', config.get('http', 'bind', fallback='127.0.0.1'), config.get('http', 'port', fallback='8080')],
        'cwd': 'www',
        'log': 'log/http.out',
    },
    'ffmpeg': {
        'name': 'ffmpeg',
        'cmd': [config.get('ffmpeg', 'command_ffmpeg', fallback='ffmpeg'), '-f', config.get('ffmpeg', 'format', fallback='alsa'), '-i', config.get('ffmpeg', 'device', fallback='default'), '-c:a', 'mp3', '-map', '0', '-flags', '-global_header', '-f', 'hls', '-hls_flags', 'delete_segments+temp_file', '-hls_segment_filename', 'stream.%03d.ts', 'stream.m3u8'],
        'ok': [0, 255],
        'cwd': 'www/stream',
        'log': 'log/ffmpeg.out',
    },
    'update': {
        'name': 'updater',
        'init': [config.get('updater', 'command_npm', fallback='npm'), 'install'],
        'cmd': [config.get('updater', 'command_npm', fallback='npm'), 'start', '--', '-p', config.get('updater', 'port', fallback='8081'), '-b', config.get('updater', 'bind', fallback='127.0.0.1')],
        'cwd': 'upd',
        'log': 'log/upd.out',
    },
}


if __name__ == '__main__':
    logs = {}

    try:
        for component, spec in components.items():
            logs[component] = open(spec['log'], 'a')

        for log in logs.values():
            print(file=log)
            print('==============', file=log)
            print('Starting Radio', file=log)
            print('==============', file=log)
            print(file=log)
            log.flush()

        init_procs = {}

        try:
            for component, spec in components.items():
                if 'init' in spec:
                    init_procs[component] = subprocess.Popen(spec['init'], stdout=logs[component], stderr=subprocess.STDOUT, cwd=spec['cwd'])

            for proc in init_procs.values():
                proc.wait()

            errors = []

            for component, proc in init_procs.items():
                ret = proc.poll()
                if 'ok' in components[component]:
                    if ret in components[component]['ok']:
                        ret = 0
                if ret:
                    errors.append((components[component]['name'], ret, proc.args))

            if errors:
                raise RuntimeError('component initialization errors:\n\t' + '\n\t'.join('{} - (exit code: {}) {}'.format(name, ret, repr(cmd)) for name, ret, cmd in errors))
        finally:
            for proc in init_procs.values():
                try:
                    proc.terminate()
                    proc.wait()
                except Exception:
                    pass

        procs = {}

        try:
            for component, spec in components.items():
                if 'cmd' in spec:
                    procs[component] = subprocess.Popen(spec['cmd'], stdout=logs[component], stderr=subprocess.STDOUT, cwd=spec['cwd'])

            display = CarillonDisplay()

            signal.signal(signal.SIGINT, lambda signum, siginfo: display.exit())
            signal.signal(signal.SIGTERM, lambda signum, siginfo: display.exit())
            signal.signal(signal.SIGCHLD, lambda signum, siginfo: display.exit())

            display.run()

            errors = []

            for component, proc in procs.items():
                ret = proc.poll()
                if 'ok' in components[component]:
                    if ret in components[component]['ok']:
                        ret = 0
                if ret:
                    errors.append((components[component]['name'], ret, proc.args))

            if errors:
                raise RuntimeError('component errors:\n\t' + '\n\t'.join('{} - (exit code: {}) {}'.format(name, ret, repr(cmd)) for name, ret, cmd in errors))
        finally:
            for proc in procs.values():
                try:
                    proc.terminate()
                    proc.wait()
                except Exception:
                    pass
    finally:
        for log in logs.values():
            try:
                log.close()
            except Exception:
                pass
