#!/usr/bin/env python3
import configparser
import json
import os
import signal
import subprocess
import sys

import urwid


class CarillonDisplay:
    def __init__(self):
        self.title = urwid.Edit('Title: ')
        self.composer = urwid.Edit('Composer: ')
        self.live = urwid.CheckBox('Live')

        self.update_button = urwid.Button('Update', self.update)
        self.clear_button = urwid.Button('Clear', self.clear)
        self.buttons = urwid.Columns([(10, self.update_button), urwid.Divider(), (9, self.clear_button)])
        self.feedback = urwid.Text('', align='center')
        self.feedback_timer = -1

        self.pile = urwid.Pile([self.title, self.composer, self.live, urwid.Divider(), self.buttons, urwid.Divider(), self.feedback])

        self.loop = urwid.MainLoop(urwid.Filler(urwid.Padding(self.pile, width=40, align='center')))

        self.last_mtime = 0

        self.running = True
        self.clear()
        self.feedback_timer = 0
        self.refresh()
        self.running = False

    def run(self):
        self.running = True
        self.loop.run()

    def exit(self):
        self.running = False

    def refresh(self, _=None, __=None):
        mtime = os.stat(os.path.dirname(__file__) + '/www/stream/metadata.json').st_mtime
        if mtime > self.last_mtime:
            self.last_mtime = mtime

            with open(os.path.dirname(__file__) + '/www/stream/metadata.json', 'r') as file:
                data = json.loads(file.read())
                self.live.state = data['live']
                self.title.edit_text = data['title']
                self.composer.edit_text = data['composer']

        if self.feedback_timer == 0:
            self.feedback.set_text('')

        if self.feedback_timer >= 0:
            self.feedback_timer -= 1

        if not self.running:
            raise urwid.ExitMainLoop()

        self.loop.set_alarm_in(1, self.refresh)

    def update(self, _=None):
        with open(os.path.dirname(__file__) + '/www/stream/metadata.json', 'w') as file:
            file.write(json.dumps({'live': self.live.state, 'title': self.title.edit_text, 'composer': self.composer.edit_text}))

        self.feedback.set_text('Stream metadata updated!')
        self.feedback_timer = 2

    def clear(self, _=None):
        self.title.set_edit_text('None')
        self.composer.set_edit_text('None')
        self.live.set_state(False)

        self.update(_)


os.chdir(os.path.dirname(__file__))


config = configparser.ConfigParser()
config.read('carillon.cfg')


http_cmd = [sys.executable, '-m', 'http.server', '-b', config.get('http', 'bind', fallback='127.0.0.1'), '-d', 'www', config.get('http', 'port', fallback='8080')]
ffmpeg_cmd = [config.get('ffmpeg', 'command_ffmpeg', fallback='ffmpeg'), '-f', config.get('ffmpeg', 'format', fallback='alsa'), '-i', config.get('ffmpeg', 'device', fallback='default'), '-c:a', 'mp3', '-map', '0', '-flags', '-global_header', '-f', 'hls', '-hls_flags', 'delete_segments+temp_file', '-hls_segment_filename', 'www/stream/stream.%03d.ts', 'www/stream/stream.m3u8']
update_cmd = ['/bin/sh', '-c', 'cd upd && "{npm}" install && exec "{npm}" start -- -p "{port}" -b "{addr}"'.format(npm=config.get('updater', 'command_npm', fallback='npm'), port=config.get('updater', 'port', fallback='8081'), addr=config.get('updater', 'bind', fallback='127.0.0.1'))]


if __name__ == '__main__':
    with open('log/http.out', 'a') as http_out, open('log/ffmpeg.out', 'a') as ffmpeg_out, open('log/upd.out', 'a') as update_out:
        for file in [http_out, ffmpeg_out, update_out]:
            print(file=file)
            print('================', file=file)
            print('Restarting Radio', file=file)
            print('================', file=file)
            print(file=file)

        try:
            http = subprocess.Popen(http_cmd, stdout=http_out, stderr=subprocess.STDOUT)
            ffmpeg = subprocess.Popen(ffmpeg_cmd, stdout=ffmpeg_out, stderr=subprocess.STDOUT)
            update = subprocess.Popen(update_cmd, stdout=update_out, stderr=subprocess.STDOUT)

            display = CarillonDisplay()

            signal.signal(signal.SIGINT, lambda signum, siginfo: display.exit())
            signal.signal(signal.SIGTERM, lambda signum, siginfo: display.exit())
            signal.signal(signal.SIGCHLD, lambda signum, siginfo: display.exit())

            display.run()
        finally:
            try:
                ret = http.poll()
                if ret:
                    sys.stderr.write('web server returned an error ({})\n'.format(ret))
                else:
                    http.terminate()
                    http.wait()
            except Exception:
                pass
            try:
                ret = ffmpeg.poll()
                if ret and ret != 255:
                    sys.stderr.write('ffmpeg returned an error ({})\n'.format(ret))
                else:
                    ffmpeg.terminate()
                    ffmpeg.wait()
            except Exception:
                pass
            try:
                ret = update.poll()
                if ret:
                    sys.stderr.write('updater returned an error ({})\n'.format(ret))
                else:
                    update.terminate()
                    update.wait()
            except Exception:
                pass
